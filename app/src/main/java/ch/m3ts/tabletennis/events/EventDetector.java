package ch.m3ts.tabletennis.events;

import android.support.annotation.NonNull;

import com.google.audio.ImplAudioRecorderCallback;

import java.util.List;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.TimeUnit;

import ch.m3ts.event.EventBus;
import ch.m3ts.event.TTEvent;
import ch.m3ts.event.TTEventBus;
import ch.m3ts.event.data.eventdetector.BallBounceAudioData;
import ch.m3ts.event.data.eventdetector.BallBounceData;
import ch.m3ts.event.data.eventdetector.BallDroppedSideWaysData;
import ch.m3ts.event.data.eventdetector.BallMovingIntoNetData;
import ch.m3ts.event.data.eventdetector.BallNearlyOutOfFrameData;
import ch.m3ts.event.data.eventdetector.BallTrackData;
import ch.m3ts.event.data.eventdetector.DetectionTimeOutData;
import ch.m3ts.event.data.eventdetector.StrikerSideChangeData;
import ch.m3ts.event.data.eventdetector.TableSideChangeData;
import ch.m3ts.tabletennis.Table;
import ch.m3ts.tabletennis.events.timeouts.TimeoutTimerTask;
import ch.m3ts.tabletennis.helper.DirectionX;
import ch.m3ts.tabletennis.helper.DirectionY;
import ch.m3ts.tabletennis.helper.Side;
import ch.m3ts.tracker.ZPositionCalc;
import cz.fmo.Lib;
import cz.fmo.data.Track;
import cz.fmo.data.TrackSet;
import cz.fmo.util.Config;

/**
 * This class tries to interpret the Detections and Tracks generated by FMO and calls methods when
 * it perceives an event. As the FMO library generates detections not only caused by the ball,
 * a filtering mechanism is implemented (selectTrack).
 * <p>
 * Currently an event can be:
 * - A bounce (onBounce)
 * - A table side change (onTableSideChange)
 * - A direction change by the ball (onSideChange)
 * - A trace of the ball (onStrikeFound)
 * - A ball moving out of the frame (onOutOfFrame)
 * - A ball falling off sideways the table (onBallDroppedSideWays)
 * - A ball detection missing for some time (onTimeout)
 */
public class EventDetector implements Lib.Callback, ImplAudioRecorderCallback.Callback {
    private static final double PERCENTAGE_OF_NEARLY_OUT_OF_FRAME = 0.07;
    private static final int MILLISECONDS_TILL_TIMEOUT = 1500;
    private final Object mLock = new Object();
    private final TrackSet tracks;
    private final int[] nearlyOutOfFrameThresholds;
    private final int srcWidth;
    private final int srcHeight;
    private Lib.Detection previousDetection;
    private int previousDirectionY;
    private int previousDirectionX;
    private int previousCenterX;
    private int previousCenterY;
    private final Table table;
    private int numberOfDetections;
    private final ZPositionCalc zPositionCalc;
    private Track currentTrack;
    private final EventBus eventBus;
    private Timer timeoutTimer;
    private BallCurvePredictor ballCurvePredictor;
    private boolean checkForBallMovingIntoNet;

    public EventDetector(Config config, int srcWidth, int srcHeight, TrackSet tracks, @NonNull Table table, ZPositionCalc calc) {
        this.eventBus = TTEventBus.getInstance();
        this.srcHeight = srcHeight;
        this.srcWidth = srcWidth;
        this.tracks = tracks;
        this.nearlyOutOfFrameThresholds = new int[]{
                (int) (srcWidth * PERCENTAGE_OF_NEARLY_OUT_OF_FRAME),
                (int) (srcWidth * (1 - PERCENTAGE_OF_NEARLY_OUT_OF_FRAME)),
                (int) (srcHeight * PERCENTAGE_OF_NEARLY_OUT_OF_FRAME),
                (int) (srcHeight * (1 - PERCENTAGE_OF_NEARLY_OUT_OF_FRAME)),
        };
        this.table = table;
        this.numberOfDetections = 0;
        this.zPositionCalc = calc;
        this.timeoutTimer = new Timer("timeoutTimer");
        this.ballCurvePredictor = new LinearBallCurvePredictor();
        this.checkForBallMovingIntoNet = true;
        tracks.setConfig(config);
    }

    @Override
    public void log(String message) {
        // Lib logs will be ignored for now
    }

    @Override
    public void onObjectsDetected(Lib.Detection[] detections) {
        this.onObjectsDetected(detections, System.nanoTime());
    }

    @Override
    public void onAudioBounceDetected() {
        if (currentTrack != null &&
                TimeUnit.MILLISECONDS.convert(System.nanoTime() - currentTrack.getLastDetectionTime(), TimeUnit.NANOSECONDS) < 30) {
            Side ballBouncedOnSide = table.getHorizontalSideOfDetection(previousDetection.centerX);
            eventBus.dispatch(new TTEvent<>(new BallBounceAudioData(ballBouncedOnSide)));
        }
    }

    public void onObjectsDetected(Lib.Detection[] detections, long detectionTime) {
        synchronized (mLock) {
            tracks.addDetections(detections, this.srcWidth, this.srcHeight, detectionTime); // after this, object direction is up to date
            if (!tracks.getTracks().isEmpty()) {
                Track track = selectTrack(tracks.getTracks());
                if (track != null && track.getLatest() != previousDetection) {
                    numberOfDetections++;
                    Lib.Detection latestDetection = track.getLatest();
                    calcDirectionY(latestDetection);
                    calcDirectionX(latestDetection);
                    callAllOnStrikeFound(track);
                    hasBallFallenOffSideWays(latestDetection);
                    isMovingIntoNet(latestDetection);
                    hasTableSideChanged(latestDetection.centerX);
                    boolean tableSideChanged = hasSideChanged(latestDetection);
                    hasBouncedOnTable(latestDetection, tableSideChanged);
                    Side nearlyOutOfFrameSide = getNearlyOutOfFrameSide(latestDetection);
                    if (nearlyOutOfFrameSide != null) {
                        callAllOnNearlyOutOfFrame(latestDetection, nearlyOutOfFrameSide);
                    }
                    savePreviousDetection(latestDetection);
                    setTimeoutTimer(numberOfDetections);
                }
            }
        }
    }

    public Track selectTrack(List<Track> tracks) {
        // first tag all tracks which have crossed the table once
        for (Track t : tracks) {
            Lib.Detection latestDetection = t.getLatest();
            latestDetection.centerZ = zPositionCalc.findZPosOfBallRel(latestDetection.radius);
            if (table.isOnOrAbove(latestDetection.centerX, latestDetection.centerY) && zPositionCalc.isBallZPositionOnTable(latestDetection.radius)) {
                t.setTableCrossed();
            }
        }

        // if there are multiple tracks, select the one with the minimum distance to previous detection
        Track selectedTrack = null;
        if (tracks.size() > 1) {
            double distance = Double.MAX_VALUE;
            for (Track t : tracks) {
                Lib.Detection d = t.getLatest();
                double a = Math.abs(d.centerX - previousCenterX);
                double b = Math.abs(d.centerY - previousCenterY);
                double distanceToLast = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
                if (distanceToLast < distance) {
                    selectedTrack = t;
                    distance = distanceToLast;
                    currentTrack = t;
                }
            }
        }

        // if there's only one track, select the newest track (highest index)
        if (selectedTrack == null) {
            for (int i = tracks.size() - 1; i >= 0; i--) {
                if (isOnTable(tracks.get(i))) {
                    selectedTrack = tracks.get(i);
                    currentTrack = selectedTrack;
                    break;
                }
            }
        }

        return selectedTrack;
    }

    public int[] getNearlyOutOfFrameThresholds() {
        return nearlyOutOfFrameThresholds;
    }

    public void callAllOnTimeout() {
        eventBus.dispatch(new TTEvent<>(new DetectionTimeOutData()));
    }

    public int getNumberOfDetections() {
        return numberOfDetections;
    }

    private void setTimeoutTimer(int currentNumberOfDetections) {
        TimerTask timeoutTimerTask = new TimeoutTimerTask(this, currentNumberOfDetections);
        timeoutTimer.schedule(timeoutTimerTask, MILLISECONDS_TILL_TIMEOUT);
    }

    private void savePreviousDetection(Lib.Detection detection) {
        // important check, if removed dirX and dirY will be set to 0 sometimes
        if (detection != this.previousDetection) {
            this.previousCenterX = detection.centerX;
            this.previousCenterY = detection.centerY;
            this.previousDirectionX = (int) detection.directionX;
            this.previousDirectionY = (int) detection.directionY;
            this.previousDetection = detection;
        }
    }

    private void callAllOnStrikeFound(Track track) {
        eventBus.dispatch(new TTEvent<>(new BallTrackData(track)));
    }

    private void callAllOnBounce(Lib.Detection detection, Side side) {
        eventBus.dispatch(new TTEvent<>(new BallBounceData(detection, side)));
    }

    private void callAllOnSideChange(Side side) {
        eventBus.dispatch(new TTEvent<>(new StrikerSideChangeData(side)));
    }

    private void callAllOnNearlyOutOfFrame(Lib.Detection latestDetection, Side side) {
        eventBus.dispatch(new TTEvent<>(new BallNearlyOutOfFrameData(latestDetection, side)));
    }

    private void callAllOnTableSideChange(Side side) {
        eventBus.dispatch(new TTEvent<>(new TableSideChangeData(side)));
    }

    private void callAllOnBallDroppedSideWays() {
        eventBus.dispatch(new TTEvent<>(new BallDroppedSideWaysData()));
    }

    private boolean hasSideChanged(Lib.Detection detection) {
        boolean hasSideChanged = false;
        if (detection.directionX != previousDirectionX) {
            Side striker = Side.getOppositeX(detection.directionX);
            callAllOnSideChange(striker);
            hasSideChanged = true;
            checkForBallMovingIntoNet = true;
        }
        return hasSideChanged;
    }

    private void hasBouncedOnTable(Lib.Detection detection, boolean hasSideChanged) {
        if (!hasSideChanged && previousDirectionY != detection.directionY &&
                (previousDirectionX == detection.directionX) &&
                (table.isBounceOn(previousCenterX, previousCenterY) || table.isBounceOn(detection.centerX, detection.centerY)) &&
                ((previousDirectionY == DirectionY.DOWN) && (detection.directionY == DirectionY.UP))) {
            Side ballBouncedOnSide = table.getHorizontalSideOfDetection(previousDetection.centerX);
            detection.isBounce = true;
            callAllOnBounce(previousDetection, ballBouncedOnSide);
        }
    }

    private Side getNearlyOutOfFrameSide(Lib.Detection detection) {
        Side side = null;
        if (detection.predecessor != null) {
            if (detection.centerX < nearlyOutOfFrameThresholds[0] && detection.directionX == DirectionX.LEFT) {
                side = Side.LEFT;
            } else if (detection.centerX > nearlyOutOfFrameThresholds[1] && detection.directionX == DirectionX.RIGHT) {
                side = Side.RIGHT;
            } else if (detection.centerY < nearlyOutOfFrameThresholds[2] && detection.directionY == DirectionY.UP) {
                side = Side.TOP;
            } else if (detection.centerY > nearlyOutOfFrameThresholds[3] && detection.directionY == DirectionY.DOWN) {
                side = Side.BOTTOM;
            }
        }
        return side;
    }

    private boolean isOnTable(Track track) {
        return track.hasCrossedTable();
    }

    private void calcDirectionY(Lib.Detection detection) {
        detection.directionY = Integer.compare(detection.centerY, previousCenterY);
    }

    private void calcDirectionX(Lib.Detection detection) {
        if (detection.predecessor != null)
            detection.directionX = Integer.compare(detection.centerX, detection.predecessor.centerX);
        else detection.directionX = Integer.compare(detection.centerX, previousCenterX);
    }

    private void hasTableSideChanged(int currentXPosition) {
        if (currentXPosition > table.getNetBottom().x && previousCenterX < table.getNetBottom().x) {
            callAllOnTableSideChange(Side.RIGHT);
        } else if (currentXPosition < table.getNetBottom().x && previousCenterX > table.getNetBottom().x) {
            callAllOnTableSideChange(Side.LEFT);
        }
    }

    private void hasBallFallenOffSideWays(Lib.Detection detection) {
        if (detection.predecessor != null &&
                table.isBelow(detection.centerX, detection.centerY) &&
                detection.directionY == DirectionY.DOWN) {
            callAllOnBallDroppedSideWays();
        }
    }

    private void isMovingIntoNet(Lib.Detection detection) {
        if (checkForBallMovingIntoNet &&
                detection.predecessor != null &&
                detection.directionY == DirectionY.DOWN &&
                table.isOnOrAbove(detection.centerX, detection.centerY) &&
                ((detection.directionX == DirectionX.RIGHT && detection.centerX < table.getNetBottom().x) ||
                        (detection.directionX == DirectionX.LEFT && detection.centerX > table.getNetBottom().x))) {
            int[] lastCXs = {
                    detection.centerX,
                    detection.predecessor.centerX,
            };
            int[] lastCYs = {
                    detection.centerY,
                    detection.predecessor.centerY,
            };
            if (ballCurvePredictor.willBallMoveIntoNet(lastCXs, lastCYs, table)) {
                eventBus.dispatch(new TTEvent<>(new BallMovingIntoNetData()));
                // no need to check twice in same strike
                checkForBallMovingIntoNet = false;
            }
        }
    }
}