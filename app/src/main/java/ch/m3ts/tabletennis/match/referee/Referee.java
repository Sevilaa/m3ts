package ch.m3ts.tabletennis.match.referee;

import java.util.Timer;
import java.util.TimerTask;

import ch.m3ts.Log;
import ch.m3ts.tabletennis.events.EventDetectionCallback;
import ch.m3ts.tabletennis.events.GestureCallback;
import ch.m3ts.tabletennis.events.ReadyToServeCallback;
import ch.m3ts.tabletennis.helper.DirectionX;
import ch.m3ts.tabletennis.helper.Side;
import ch.m3ts.tabletennis.match.game.Game;
import ch.m3ts.tabletennis.match.game.GameCallback;
import ch.m3ts.tabletennis.match.game.ScoreManipulationCallback;
import ch.m3ts.tabletennis.timeouts.OutOfFrameTimerTask;
import cz.fmo.Lib;
import cz.fmo.data.Track;

/**
 * Represents a referee inside a table tennis match.
 * Based off the events generated by the EventDetector, decides whether a player has scored or
 * made a fault depending of the state of the Referee.
 * <p>
 * Currently the referee states are as follows:
 * - PLAY -> both players are currently playing the game
 * - SERVING -> a player is serving (when the ball is still on the servers' side)
 * - WAIT_FOR_SERVE -> a player will be serving shortly
 * - PAUSE -> a player just scored
 * - OUT_OF_FRAME -> the ball is not inside the frame anymore, the referee needs to wait and see
 * if a player can shoot the ball back onto the table.
 */
public class Referee implements EventDetectionCallback, ScoreManipulationCallback, ReadyToServeCallback {
    private static final int OUT_OF_FRAME_MAX_DELAY = 1000;
    private final GestureCallback gestureCallback;
    private Timer outOfFrameTimer;
    private Timer timeOutNextServeTimer;
    private GameCallback gameCallback;
    private Game currentGame;
    private Side currentStriker;
    private Side currentBallSide;
    private State state;
    private int bounces;
    private int audioBounces;

    public Referee(Side servingSide, GestureCallback gestureCallback) {
        this.currentStriker = servingSide;
        this.currentBallSide = servingSide;
        this.bounces = 0;
        this.audioBounces = 0;
        this.state = State.WAIT_FOR_SERVE;
        this.gestureCallback = gestureCallback;
    }

    public void setGame(Game game, boolean firstGame) {
        this.gameCallback = game;
        this.currentGame = game;
        if (!firstGame) {
            initWaitingForGesture();
        }
    }

    public void initWaitingForGesture() {
        this.state = State.PAUSE;
        this.gestureCallback.onWaitingForGesture(getServer());
    }

    public State getState() {
        return state;
    }

    public Side getServer() {
        return currentGame.getServer();
    }

    public Side getCurrentStriker() {
        return currentStriker;
    }

    @Override
    public void onBounce(Lib.Detection detection, Side ballBouncedOnSide) {
        switch (this.state) {
            case SERVING:
                if (ballBouncedOnSide == currentBallSide) {
                    bounces++;
                    applyRuleSetServing();
                }
                break;
            case PLAY:
                if (ballBouncedOnSide == currentBallSide) {
                    bounces++;
                    applyRuleSet();
                }
                break;
            default:
                break;
        }
    }

    @Override
    public void onAudioBounce(Side ballBouncedOnSide) {
        switch (this.state) {
            case SERVING:
            case PLAY:
                if (ballBouncedOnSide == currentBallSide) {
                    Log.d("Referee: Audio bounce detected in PLAY state");
                    audioBounces++;
                }
                break;
            default:
                break;
        }
    }

    @Override
    public void onSideChange(Side side) {
        switch (this.state) {
            case PLAY:
                // do not change striker if the ball was sent back by net
                if (currentBallSide == side) {
                    bounces = 0;
                    audioBounces = 0;
                    currentStriker = side;
                }
                break;
            case SERVING:
                if (side != getServer()) {
                    bounces = 0;
                    audioBounces = 0;
                }
                if (currentBallSide == side) {
                    currentStriker = side;
                }
                break;
            case PAUSE:
                if (side == getServer()) {
                    this.gameCallback.onNotReadyButPlaying();
                }
                currentStriker = side;
                break;
            default:
                currentStriker = side;
                break;
        }
    }

    @Override
    public void onNearlyOutOfFrame(Lib.Detection detection, Side side) {
        if (this.state == State.PLAY && side != Side.TOP)
            handleOutOfFrame();
    }

    @Override
    public void onStrikeFound(Track track) {
        switch (this.state) {
            case WAIT_FOR_SERVE:
                Lib.Detection latestDetection = track.getLatest();
                if (((getServer() == Side.LEFT && currentBallSide == Side.LEFT && latestDetection.directionX == DirectionX.RIGHT) ||
                        (getServer() == Side.RIGHT && currentBallSide == Side.RIGHT && latestDetection.directionX == DirectionX.LEFT)) &&
                        (latestDetection.predecessor != null)) {
                    this.state = State.SERVING;
                    currentBallSide = getServer();
                    this.currentStriker = getServer();
                }
                break;
            case OUT_OF_FRAME:
                // if ball was out of frame for too long, a point would have been scored.
                this.outOfFrameTimer.cancel();
                this.outOfFrameTimer = null;
                this.state = State.PLAY;
                break;
            default:
                break;
        }
    }

    @Override
    public void onTableSideChange(Side side) {
        // set the currentStriker in case the tracker didn't find any detections
        this.currentStriker = Side.getOpposite(side);
        this.currentBallSide = side;
        switch (this.state) {
            case SERVING:
            case PLAY:
                this.state = State.PLAY;
                this.bounces = 0;
                this.audioBounces = 0;
                break;
            default:
                break;
        }
    }

    @Override
    public void onBallDroppedSideWays() {
        switch (this.state) {
            case PLAY:
                if (bounces == 0) {
                    Log.d("Fault by Striker: Ball has fallen off side ways and had no bounce");
                    faultBySide(currentStriker);
                } else if (bounces == 1) {
                    Log.d("Point by Striker: Ball has fallen off side ways and had a bounce");
                    pointBySide(currentStriker);
                }
                break;
            default:
                break;
        }
    }

    @Override
    public void onTimeout() {
        if (this.state == State.PLAY || this.state == State.SERVING)
            handleOutOfFrame();
    }

    @Override
    public void onPointDeduction(Side side) {
        gameCallback.onPointDeduction(side);
        initPoint();
        this.state = State.PAUSE;
        gestureCallback.onWaitingForGesture(getServer());
    }

    @Override
    public void onPointAddition(Side side) {
        gameCallback.onPoint(side);
        initPoint();
        this.state = State.PAUSE;
        gestureCallback.onWaitingForGesture(getServer());
    }

    @Override
    public void onPause() {
        this.pause();
    }

    @Override
    public void onResume() {
        this.resume();
    }

    public Side getCurrentBallSide() {
        return currentBallSide;
    }

    public void onOutOfFrameForTooLong() {
        if (this.state == State.OUT_OF_FRAME) {
            if (currentBallSide == currentStriker) {
                Log.d("Out of Frame for too long - Striker most likely shot the ball into the net");
                faultBySide(currentStriker);
            } else if (this.bounces >= 1 || this.audioBounces >= 1) {
                if (this.audioBounces >= 1)
                    Log.d("Out of Frame for too long (AUDIO_BOUNCE) - Strike received no return");
                else Log.d("Out of Frame for too long - Strike received no return");
                pointBySide(currentStriker);
            } else {
                Log.d("Out of Frame for too long - Strike did not bounce");
                faultBySide(currentStriker);
            }
        } else {
            this.outOfFrameTimer = null;
        }
    }

    public void resume() {
        this.state = State.WAIT_FOR_SERVE;
        this.gameCallback.onReadyToServe(getServer());
    }

    private void pause() {
        this.state = State.PAUSE;
        cancelTimers();
    }

    private void cancelTimers() {
        if (this.outOfFrameTimer != null) {
            this.outOfFrameTimer.cancel();
            this.outOfFrameTimer = null;
        }
        if (this.timeOutNextServeTimer != null) {
            this.timeOutNextServeTimer.cancel();
            this.timeOutNextServeTimer = null;
        }
    }

    private void handleOutOfFrame() {
        // schedule out of frame timer
        TimerTask outOfFrameTask = new OutOfFrameTimerTask(this);
        outOfFrameTimer = new Timer("outOfFrameTimer");
        outOfFrameTimer.schedule(outOfFrameTask, OUT_OF_FRAME_MAX_DELAY);
        this.state = State.OUT_OF_FRAME;
    }

    private void pointBySide(Side side) {
        gameCallback.onPoint(side);
        initPoint();
        this.state = State.PAUSE;
        gestureCallback.onWaitingForGesture(getServer());
    }

    private void faultBySide(Side side) {
        gameCallback.onPoint(Side.getOpposite(side));
        initPoint();
        this.state = State.PAUSE;
        gestureCallback.onWaitingForGesture(getServer());
    }

    private void initPoint() {
        this.bounces = 0;
        this.audioBounces = 0;
        this.cancelTimers();
        this.state = State.WAIT_FOR_SERVE;
    }

    private void applyRuleSet() {
        if (bounces == 1) {
            if (this.currentStriker == this.currentBallSide) {
                Log.d("currentStriker: " + this.currentStriker);
                Log.d("currentBallSide: " + this.currentBallSide);
                Log.d("Bounce on same Side");
                faultBySide(this.currentStriker);
            }
        } else if (bounces >= 2 && this.currentStriker != this.currentBallSide) {
            Log.d("Double Bounce");
            pointBySide(this.currentStriker);
        }
    }

    private void applyRuleSetServing() {
        if (bounces > 1 && currentBallSide == getServer()) {
            Log.d("Server Fault: Multiple Bounces on same Side");
            faultBySide(getServer());
        }
    }

    @Override
    public void onGestureDetected() {
        resume();
    }
}
